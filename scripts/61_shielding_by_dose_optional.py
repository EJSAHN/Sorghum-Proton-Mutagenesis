# -*- coding: utf-8 -*-
"""
61_shielding_by_dose_optional.py

Optional: compute functional enrichment *by dose* (radiation x dose x category).

Depends on:
  - outputs_functional_shielding/tables/events_annotated_v2.csv.gz
  - outputs_functional_shielding/tables/expected_callable_space_probs.csv
(Generated by step 60.)

Outputs:
  - outputs_functional_shielding/tables/shielding_corrected_by_dose.csv
"""
from __future__ import annotations

import argparse
import pandas as pd
from scipy.stats import binomtest

from pipeline_utils import resolve_project_paths


def format_p_value(p: float) -> str:
    if p < 1e-100:
        return "<1e-100"
    return f"{p:.3e}"


def main() -> None:
    ap = argparse.ArgumentParser()
    ap.add_argument("--project-root", default=None)
    args = ap.parse_args()

    paths = resolve_project_paths(args.project_root)

    ann_path = paths.outputs_functional / "tables" / "events_annotated_v2.csv.gz"
    probs_path = paths.outputs_functional / "tables" / "expected_callable_space_probs.csv"
    if not ann_path.exists():
        raise FileNotFoundError(f"Missing annotated events: {ann_path}")
    if not probs_path.exists():
        raise FileNotFoundError(f"Missing callable-space probs: {probs_path}. Run step 60 first.")

    events = pd.read_csv(ann_path, compression="gzip")
    probs = pd.read_csv(probs_path)

    expected_probs = dict(zip(probs["Category"].astype(str), probs["callable_prob"].astype(float)))
    categories = ["Promoter", "CDS", "Intron", "Intergenic"]
    for c in categories:
        if c not in expected_probs:
            raise ValueError(f"Category '{c}' missing from expected probs.")

    # Observed counts by rad x dose x category
    obs = (
        events.groupby(["rad_type", "dose_Gy", "Category"])
              .size()
              .reset_index(name="Observed")
    )

    rows = []
    for (rad, dose), sub in obs.groupby(["rad_type", "dose_Gy"]):
        total_mut = int(sub["Observed"].sum())
        by_cat = dict(zip(sub["Category"].astype(str), sub["Observed"].astype(int)))
        for cat in categories:
            observed = int(by_cat.get(cat, 0))
            expected = expected_probs[cat] * total_mut
            enrichment = (observed / expected) if expected > 0 else float("nan")
            pval = binomtest(k=observed, n=total_mut, p=expected_probs[cat], alternative="two-sided").pvalue

            rows.append({
                "Radiation": rad,
                "Dose_Gy": int(dose) if pd.notna(dose) else dose,
                "Feature": cat,
                "Observed": observed,
                "Expected": float(expected),
                "Enrichment": float(enrichment),
                "P_value": format_p_value(float(pval)),
            })

    out_df = pd.DataFrame(rows).sort_values(["Radiation", "Dose_Gy", "Feature"])
    out_path = paths.outputs_functional / "tables" / "shielding_corrected_by_dose.csv"
    out_df.to_csv(out_path, index=False)
    print(f"[OK] Saved: {out_path}")


if __name__ == "__main__":
    main()
